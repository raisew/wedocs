import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.yVxbj29m.js";
const __pageData = JSON.parse('{"title":"输入URL至页面显示的过程","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/1-前端/1-Web/1 网络/8-输入URL_至页面显示的过程.md","filePath":"markdown/1-前端/1-Web/1 网络/8-输入URL_至页面显示的过程.md"}');
const _sfc_main = { name: "markdown/1-前端/1-Web/1 网络/8-输入URL_至页面显示的过程.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="输入url至页面显示的过程" tabindex="-1">输入URL至页面显示的过程 <a class="header-anchor" href="#输入url至页面显示的过程" aria-label="Permalink to &quot;输入URL至页面显示的过程&quot;">​</a></h1><h2 id="网络过程" tabindex="-1">网络过程 <a class="header-anchor" href="#网络过程" aria-label="Permalink to &quot;网络过程&quot;">​</a></h2><ol><li><p>输⼊ URL，浏览器解析 URL</p><ul><li>是合法的 URL，且自动补全前缀或后缀</li><li>不是合法的 URL，则调用搜索引擎搜索</li></ul></li><li><p>DNS 解析域名，获取 ip 地址</p><ul><li>浏览器 -&gt; 系统（host 文件）-&gt; 路由器 -&gt; ISP -&gt; <strong>DNS 递归查询</strong></li></ul></li><li><p>浏览器查看是否命中<strong>强缓存</strong></p><ul><li>查看 <strong>Expires</strong>（HTTP 1.0，绝对时间）和 <strong>Cache-Control</strong> （HTTP 1.1，最大新鲜时间），若命中强缓存则直接返回缓存</li></ul></li><li><p>建立 <strong>TCP</strong> 链接，进行<strong>三次握手</strong></p><ul><li>客户端 <strong>SYN=1</strong>，<strong>Seq=X</strong> 的包到服务器端</li><li>服务器发回 <strong>SYN=1</strong>，<strong>ACK=X+1</strong>， <strong>Seq=Y</strong> 的响应包</li><li>客户端发送 <strong>ACK=Y+1</strong>， <strong>Seq=Z</strong></li></ul></li><li><p>若协议为 <strong>HTTPS</strong>，则会进行加密</p></li><li><p>服务器检查<strong>协商缓存</strong></p><ul><li>通过 <strong>ETag</strong> 和 <strong>Last-Modify</strong> 判断资源是否过期，若未过期，返回 <strong>304</strong></li></ul></li><li><p>服务器处理请求，并返回响应报文</p></li><li><p>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接</strong>或者<strong>保留重⽤</strong>，关闭TCP连接的<strong>四次握⼿</strong>如下：</p><ul><li>客户端发送一个 <strong>FIN=1</strong>，<strong>Seq=U</strong> 的包到服务器</li><li>服务器发回 <strong>FIN=1</strong>，<strong>ACK=U+1</strong>， <strong>Seq=V</strong> 的响应包 ，此时处于半关闭状态，但可能服务器端还有一个数据要发送</li><li>数据完全发送完毕后，服务器发送 <strong>FIN=1</strong>，<strong>ACK=U+1</strong>， <strong>Seq=W</strong> 的响应包</li><li>客户端发送 <strong>ACK=W+1</strong>， <strong>Seq=U+1</strong> 的包</li></ul></li></ol><h2 id="渲染页面的过程" tabindex="-1">渲染页面的过程 <a class="header-anchor" href="#渲染页面的过程" aria-label="Permalink to &quot;渲染页面的过程&quot;">​</a></h2><ol><li><p><code>构建DOM树</code>：</p><ol><li>把字节流解码成字符流</li><li>通过词法分析器解释成词语，构建成节点</li><li>把节点组建成 <strong>DOM</strong> 树</li></ol></li><li><p>解析过程中遇到图⽚、样式表、<strong>js</strong>⽂件，<code>启动下载</code></p></li><li><p><code>构建CSSOM树</code>：</p><ol><li>把字节流解码成字符流</li><li>通过词法分析器解释成词语，构建成<strong>CSS</strong>对象</li><li>把 <strong>CSS</strong> 对象组建成 <strong>DOM</strong> 树</li></ol></li><li><p>根据<strong>DOM</strong>树和<strong>CSSOM</strong>树<code>构建渲染树</code></p><ol><li>从<strong>DOM</strong>树的根节点遍历所有可⻅节点</li><li>对每⼀个可⻅节点，找到恰当的<strong>CSSOM</strong>规则并应⽤</li><li>发布可视节点的内容和计算样式</li></ol></li><li><p>最后解析下载完成的 <strong>js</strong> 脚本</p><ol><li>浏览器创建<code>Document对象</code>并解析<strong>HTML</strong>，将解析到的<code>元素</code>和<code>⽂本节点</code>添加到⽂档中，此时<strong>document.readystate</strong>为<strong>loading</strong></li><li><strong>HTML</strong>解析器遇到<code>没有 async 和 defer 的 script</code>时，<code>同步执⾏</code>，即在脚本下载和执⾏时解析器会暂停</li><li>当解析器遇到设置了<code>async 的script</code>时，会异步下载，且在下载完成后，解析器执行脚本</li><li>所有<code>defer脚本</code>会异步下载，并在最后按照在⽂档出现的顺序执⾏</li><li>当⽂档完成解析，<strong>document.readState</strong>变成<strong>interactive</strong>，并触发 <strong>DOMContentLoaded</strong> 事件</li><li>此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些<code>内容完成载⼊</code>并且<code>所有异步脚本完成载⼊和执⾏</code>，<strong>document.readState</strong>变为<strong>complete</strong>，<strong>window</strong>触发 <strong>load</strong> 事件</li></ol></li><li><p>最后执行 <strong>ajax</strong></p></li><li><p>请求</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/kingmusi/blogImages/img/202207280032031.png" alt=""></p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("markdown/1-前端/1-Web/1 网络/8-输入URL_至页面显示的过程.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _8___URL_________ = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  _8___URL_________ as default
};
