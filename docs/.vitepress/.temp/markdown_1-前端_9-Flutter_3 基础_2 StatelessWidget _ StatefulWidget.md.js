import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.yVxbj29m.js";
const __pageData = JSON.parse('{"title":"StatelessWidget & StatefulWidget","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/1-前端/9-Flutter/3 基础/2 StatelessWidget & StatefulWidget.md","filePath":"markdown/1-前端/9-Flutter/3 基础/2 StatelessWidget & StatefulWidget.md"}');
const _sfc_main = { name: "markdown/1-前端/9-Flutter/3 基础/2 StatelessWidget & StatefulWidget.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="statelesswidget-statefulwidget" tabindex="-1">StatelessWidget &amp; StatefulWidget <a class="header-anchor" href="#statelesswidget-statefulwidget" aria-label="Permalink to &quot;StatelessWidget &amp; StatefulWidget&quot;">​</a></h1><h2 id="statelesswidget" tabindex="-1"><a href="https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html" target="_blank" rel="noreferrer">StatelessWidget</a> <a class="header-anchor" href="#statelesswidget" aria-label="Permalink to &quot;[StatelessWidget](https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html)&quot;">​</a></h2><p>一个不需要可变 state 的 Widget</p><ul><li>没有状态，它们只会被渲染一次并且不会自我更新</li></ul><blockquote><p>android studio 中输入 <code>stless</code> 可快速创建一个 StatelessWidget</p></blockquote><h2 id="statefulwidget" tabindex="-1"><a href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html" target="_blank" rel="noreferrer">StatefulWidget</a> <a class="header-anchor" href="#statefulwidget" aria-label="Permalink to &quot;[StatefulWidget](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html)&quot;">​</a></h2><p>一个拥有可变 state 的 Widget</p><ul><li>有一个 <code>setState</code> 方法，用于更新 state</li></ul><blockquote><p>android studio 中输入 <code>stful</code> 可快速创建一个 StatefulWidget</p></blockquote><h2 id="两者区别" tabindex="-1">两者区别 <a class="header-anchor" href="#两者区别" aria-label="Permalink to &quot;两者区别&quot;">​</a></h2><ol><li>能否<strong>自我重新构建</strong>(<em><strong>self rebuild</strong></em>)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kingmusi/blogImages/img/202303051855211.png" alt=""></p><ol start="2"><li>性能消耗</li></ol><p><strong><code>StatelessWidget</code> 相较于 <code>StatefulWidget</code> 性能消耗更小</strong></p><p>每次<strong>Build</strong>都需要新建和销毁大量的<strong>Widget</strong>，<strong>Element Tree</strong>的<strong>diff</strong>，甚至繁重的渲染和重绘。所以推出 <strong>StatelessWidget</strong> 就是为了性能的考虑而对开发者进行的一些约束</p><h2 id="statelesswidget-类常用组件" tabindex="-1">StatelessWidget 类常用组件 <a class="header-anchor" href="#statelesswidget-类常用组件" aria-label="Permalink to &quot;StatelessWidget 类常用组件&quot;">​</a></h2><div class="language-mermaid vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">graph LR;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A(StatelessWidget) --&gt; B(Text)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A --&gt; C(Icon)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A --&gt; D(Chip)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A --&gt; E(Divider)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A --&gt; F(Card)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A --&gt; G(AlertDialog)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="statefulwidget-类常用组件" tabindex="-1">StatefulWidget 类常用组件 <a class="header-anchor" href="#statefulwidget-类常用组件" aria-label="Permalink to &quot;StatefulWidget 类常用组件&quot;">​</a></h2><div class="language-mermaid vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">graph LR;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A(StatefulWidget) --&gt; B(Image)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A --&gt; C(TextField)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">A --&gt; D(PageView)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("markdown/1-前端/9-Flutter/3 基础/2 StatelessWidget & StatefulWidget.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _2_StatelessWidget___StatefulWidget = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  _2_StatelessWidget___StatefulWidget as default
};
