import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.yVxbj29m.js";
const __pageData = JSON.parse('{"title":"cookie sessionStorage localStorage","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/1-前端/2-HTML/2 HTML5/2-cookie session Storage localStorage.md","filePath":"markdown/1-前端/2-HTML/2 HTML5/2-cookie session Storage localStorage.md"}');
const _sfc_main = { name: "markdown/1-前端/2-HTML/2 HTML5/2-cookie session Storage localStorage.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="cookie-sessionstorage-localstorage" tabindex="-1">cookie sessionStorage localStorage <a class="header-anchor" href="#cookie-sessionstorage-localstorage" aria-label="Permalink to &quot;cookie sessionStorage localStorage&quot;">​</a></h1><h2 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h2><ul><li>使用 <code>document.cookie</code> 获取和改变</li></ul><blockquote><p><strong>cookie</strong> 作用域</p><ol><li>省略<strong>domain</strong>参数，那么<strong>domain</strong>默认为当前域名。</li><li><strong>domain</strong>参数可以设置父域名以及自身，但不能设置其它域名，包括子域名，否则<strong>cookie</strong>不起作用。</li><li>有效作用域：<strong>domain</strong>本身以及<strong>domain</strong>下的所有子域名。</li></ol></blockquote><h2 id="sessionstorage-localstorage" tabindex="-1">sessionStorage localStorage <a class="header-anchor" href="#sessionstorage-localstorage" aria-label="Permalink to &quot;sessionStorage localStorage&quot;">​</a></h2><ul><li>设置数据：<strong>setItem(key,value)</strong></li><li>获取数据：<strong>getItem(key)</strong></li><li>删除数据：<strong>removeItem(key)</strong></li><li>清空所有数据：<strong>clear()</strong></li></ul><p>上面方法的调用都会触发 <strong>storage</strong> 事件，其 <strong>event</strong> 对象上有以下属性</p><ul><li><strong>domain</strong>：存储变化对应的域</li><li><strong>key</strong>：被设置或删除的键</li><li><strong>newValue</strong>：键被设置的新值，若键被删除则为 <strong>null</strong></li><li><strong>oldValue</strong>：键变化之前的值</li></ul><h2 id="三者区别" tabindex="-1">三者区别 <a class="header-anchor" href="#三者区别" aria-label="Permalink to &quot;三者区别&quot;">​</a></h2><h4 id="传递" tabindex="-1">传递： <a class="header-anchor" href="#传递" aria-label="Permalink to &quot;传递：&quot;">​</a></h4><ol><li><strong>cookie</strong>数据始终在同源的<strong>http</strong>请求中携带（即使不需要），即会在浏览器和服务器间来回传递</li><li><strong>sessionStorage</strong> 和 <strong>localStorage</strong> 不会⾃动把数据发给服务器，仅在本地保存</li></ol><h4 id="存储大小" tabindex="-1">存储⼤⼩： <a class="header-anchor" href="#存储大小" aria-label="Permalink to &quot;存储⼤⼩：&quot;">​</a></h4><ol><li><strong>cookie</strong> 数据⼤⼩不能超过 <strong>4k</strong></li><li><strong>sessionStorage</strong> 和 <strong>localStorage</strong> 虽然也有存储⼤⼩的限制，但⽐ <strong>cookie</strong> ⼤得 多，可以达到<strong>5M或更⼤</strong></li></ol><h4 id="有期时间" tabindex="-1">有期时间： <a class="header-anchor" href="#有期时间" aria-label="Permalink to &quot;有期时间：&quot;">​</a></h4><ol><li><strong>localStorage</strong> 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据</li><li><strong>sessionStorage</strong> 数据在当前浏览器窗⼝关闭后⾃动删除</li><li><strong>cookie</strong> 设置的 <strong>cookie</strong> 过期时间之前⼀直有效，即使窗⼝或浏览器关闭</li></ol><h4 id="api-简易性" tabindex="-1">API 简易性 <a class="header-anchor" href="#api-简易性" aria-label="Permalink to &quot;API 简易性&quot;">​</a></h4><ol><li><strong>cookie</strong> 需要自己封装</li><li><strong>sessionStorage</strong> 和 <strong>localStorage</strong> 都有现成的<strong>API</strong></li></ol></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("markdown/1-前端/2-HTML/2 HTML5/2-cookie session Storage localStorage.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _2Cookie_session_Storage_localStorage = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  _2Cookie_session_Storage_localStorage as default
};
