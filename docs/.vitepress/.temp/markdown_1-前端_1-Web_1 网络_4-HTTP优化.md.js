import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.yVxbj29m.js";
const __pageData = JSON.parse('{"title":"HTTP 优化","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/1-前端/1-Web/1 网络/4-HTTP优化.md","filePath":"markdown/1-前端/1-Web/1 网络/4-HTTP优化.md"}');
const _sfc_main = { name: "markdown/1-前端/1-Web/1 网络/4-HTTP优化.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="http-优化" tabindex="-1">HTTP 优化 <a class="header-anchor" href="#http-优化" aria-label="Permalink to &quot;HTTP 优化&quot;">​</a></h1><h2 id="http-1-1-的优化" tabindex="-1">HTTP 1.1 的优化 <a class="header-anchor" href="#http-1-1-的优化" aria-label="Permalink to &quot;HTTP 1.1 的优化&quot;">​</a></h2><h4 id="_1-缓存处理" tabindex="-1">1. 缓存处理 <a class="header-anchor" href="#_1-缓存处理" aria-label="Permalink to &quot;1. 缓存处理&quot;">​</a></h4><ul><li>HTTP1.0 中主要使用 <strong>If-Modified-Since,Expires</strong> 来做为缓存判断的标准</li><li>HTTP1.1 则引入了更多的缓存控制策略例如 <strong>Entity tag，If-Unmodified-Since, If-Match, If-None-Match</strong>等更多可供选择的缓存头来控制缓存</li></ul><h4 id="_2-http1-1-新增-24-个错误状态响应码" tabindex="-1">2. HTTP1.1 新增 <strong>24</strong> 个错误状态响应码 <a class="header-anchor" href="#_2-http1-1-新增-24-个错误状态响应码" aria-label="Permalink to &quot;2. HTTP1.1 新增 **24** 个错误状态响应码&quot;">​</a></h4><h4 id="_3-增加了-request-方法-有options-put-delete-trace-connect" tabindex="-1">3. 增加了 Request 方法，有<strong>OPTIONS</strong>, <strong>PUT</strong>, <strong>DELETE</strong>, <strong>TRACE</strong>, <strong>CONNECT</strong> <a class="header-anchor" href="#_3-增加了-request-方法-有options-put-delete-trace-connect" aria-label="Permalink to &quot;3. 增加了 Request 方法，有**OPTIONS**, **PUT**, **DELETE**, **TRACE**, **CONNECT**&quot;">​</a></h4><h4 id="_4-必须存在-host-首部" tabindex="-1">4. 必须存在 Host 首部 <a class="header-anchor" href="#_4-必须存在-host-首部" aria-label="Permalink to &quot;4. 必须存在 Host 首部&quot;">​</a></h4><ul><li>在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此可以不添加 Host 头域，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址</li><li>为了区分，HTTP1.1 的请求消息和响应消息都应支持 <strong>Host头域</strong>，且请求消息中如果没有 <strong>Host头域</strong> 会报告一个错误（400 Bad Request）</li></ul><h4 id="_5-range" tabindex="-1">5. range <a class="header-anchor" href="#_5-range" aria-label="Permalink to &quot;5. range&quot;">​</a></h4><ul><li>HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了</li><li>HTTP1.1 则在请求头引入了 <strong>range</strong> 头域，它允许只请求资源的某个部分，即返回码是 <strong>206（Partial Content）</strong>，这样就方便了开发者自由的选择以便于充分利用带宽和连接</li></ul><h4 id="_6-长连接-keep-alive" tabindex="-1">6. <code>长连接</code>（keep-alive） <a class="header-anchor" href="#_6-长连接-keep-alive" aria-label="Permalink to &quot;6. \`长连接\`（keep-alive）&quot;">​</a></h4><ul><li>解决问题：每个资源都会进行一次 TCP 连接，这样会造成无谓的 TCP 连接建立（三次握手）和断开，增加通信量的开销</li><li>特点：只要任意一端没有明确提出断开连接，则保持 <strong>TCP</strong> 连接状态</li></ul><h4 id="_7-管线化-pipelining" tabindex="-1">7. <code>管线化</code>（Pipelining） <a class="header-anchor" href="#_7-管线化-pipelining" aria-label="Permalink to &quot;7. \`管线化\`（Pipelining）&quot;">​</a></h4><ul><li><p>建立在长连接的基础上</p></li><li><p>不用等待响应亦可直接发送下一个请求，则服务器可并行处理多个请求</p><p><img src="https://cdn.jsdelivr.net/gh/kingmusi/blogImages/img/202207262350187.png" alt=""></p></li><li><p>存在瓶颈：HTTP 1.x 只能严格串行地返回响应，即虽然 CSS 处理比 HTML 处理要快，但却依然要比 HTML 响应要慢，这种情况被称为<strong>队首阻塞</strong></p></li></ul><blockquote><p>HTTP 1.x 解决队首阻塞的权宜之计</p><p>使用多个 TCP 连接，每个客户端最多可以开启 6 个 TCP 连接</p></blockquote><h2 id="http-2-0-的优化" tabindex="-1">HTTP 2.0 的优化 <a class="header-anchor" href="#http-2-0-的优化" aria-label="Permalink to &quot;HTTP 2.0 的优化&quot;">​</a></h2><h4 id="_1-二进制分帧层" tabindex="-1">1. 二进制分帧层 <a class="header-anchor" href="#_1-二进制分帧层" aria-label="Permalink to &quot;1. 二进制分帧层&quot;">​</a></h4><ul><li><p>帧：HTTP2.0通信的最小单位，所有帧都共享一个8字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识符，帧承载着特定类型的数据，如HTTP首部、负荷、等等。</p></li><li><p>消息：比帧大的通讯单位，是指逻辑上的HTTP消息，比如请求、响应等。由一个或多个帧组成</p></li><li><p>流：比消息大的通讯单位。是TCP连接中的一个虚拟通道，可以承载双向的消息。每个流都有一个唯一的整数标识符</p></li></ul><p>将所有传输信息分割为更小的消息和帧，并对它们采用<strong>二进制格式</strong>的编码将其封装，所有消息都在<strong>一个TCP连接上完成</strong>，这个连接可以承载任意数量的双向数据流，帧可以<strong>乱序发送</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kingmusi/blogImages/img/202207262353418.png" alt=""></p><h4 id="_2-首部压缩" tabindex="-1">2. 首部压缩 <a class="header-anchor" href="#_2-首部压缩" aria-label="Permalink to &quot;2. 首部压缩&quot;">​</a></h4><ul><li>在客户端和服务器端使用<strong>首部表</strong>来跟踪和存储之前发送的键－值对， 对于相同的数据，不再通过每次请求和响应发送</li><li>首部表在连接存续期内始终存在，由客户端和服务器共同渐进地更新</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值</li></ul><h4 id="_3-多路复用" tabindex="-1">3. 多路复用 <a class="header-anchor" href="#_3-多路复用" aria-label="Permalink to &quot;3. 多路复用&quot;">​</a></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2f7d14013604bcd8d12a3139f39e091~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p>基于二进制分帧层，HTTP2.0可以在共享TCP链接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来</p><p><img src="https://cdn.jsdelivr.net/gh/kingmusi/blogImages/img/202207262353418.png" alt=""></p><h4 id="_4-服务器推送" tabindex="-1">4. 服务器推送 <a class="header-anchor" href="#_4-服务器推送" aria-label="Permalink to &quot;4. 服务器推送&quot;">​</a></h4><p>服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("markdown/1-前端/1-Web/1 网络/4-HTTP优化.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _4HTTP__ = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  _4HTTP__ as default
};
